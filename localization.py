# -*- coding: utf-8 -*-
"""localization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13vi7M3YvLY5SEO03jMfRnvknHF9OsWBw
"""

import tensorflow as tf
from keras.models import Model
from keras.layers import Flatten, Dense, Concatenate
from keras.optimizers import Adam
from keras.losses import binary_crossentropy, categorical_crossentropy, sparse_categorical_crossentropy
import numpy as np
import matplotlib.pyplot as plt
from imageio import imread
from skimage.transform import resize
from matplotlib.patches import Rectangle

!wget -nc https://lazyprogrammer.me/course_files/charmander-tight.png
!wget -nc https://lazyprogrammer.me/course_files/bulbasaur-tight.png
!wget -nc https://lazyprogrammer.me/course_files/squirtle-tight.png

import keras.utils as image

ch = imread('charmander-tight.png')
bb = imread('bulbasaur-tight.png')
sq = imread('squirtle-tight.png')

ch_h, ch_w, ch_c = ch.shape
bb_h, bb_w, bb_c = bb.shape
sq_h, sq_w, sq_c = sq.shape

pokemon = [
    [ch, ch_h, ch_w, ch_c],
    [bb, bb_h, bb_w, bb_c],
    [sq, sq_h, sq_w, sq_c]
]

classes = ['Charmander', 'Bulbasaur', 'Squirtle']

from glob import glob
import keras.utils as image
backgrounds = []

bgs = glob('background/*.jpg')
for b in bgs:
  k = np.array(image.load_img(b))
  backgrounds.append(k)

print(len(backgrounds))

print(backgrounds[2].shape)

IMG_SIZE = 200

from skimage.transform import resize

def data_generator(batch_size = 64):
  while True:
    for _ in range(50):
      X = np.zeros((batch_size, IMG_SIZE, IMG_SIZE, 3))
      y = np.zeros((batch_size, 8))

      for i in range(batch_size):
        random_bg = np.random.choice(len(backgrounds))
        bg = backgrounds[random_bg]
        bg_h, bg_w, _ = bg.shape
        blr = np.random.randint(low=0, high=(bg_h-IMG_SIZE+1))
        blc = np.random.randint(low=0, high=(bg_w-IMG_SIZE+1))
        X[i] = bg[blr:blr+IMG_SIZE,blc:blc+IMG_SIZE].copy()

        appear = (np.random.random() < 0.75)

        if appear:
          p_id = np.random.choice(len(pokemon))
          pk, h, w, _ = pokemon[p_id]
          scale = 0.5 + np.random.random()
          n_h = int(h*scale)
          n_w = int(w*scale)
          obj = resize(pk, (n_h, n_w), preserve_range=True).astype(np.uint8)

          if np.random.random() > 0.5:
            obj = np.fliplr(obj)

          lr = np.random.randint(low=0, high=(IMG_SIZE-n_h+1))
          lc = np.random.randint(low=0, high=(IMG_SIZE-n_w+1))
          rr = lr + n_h - 1
          rc = lc + n_w - 1

          mask = (obj[:,:,3] == 0)
          bg_slice = X[i,lr:rr+1,lc:rc+1,:]
          bg_slice = np.expand_dims(mask, -1) * bg_slice
          bg_slice += obj[:,:,:3]
          X[i,lr:rr+1,lc:rc+1,:] = bg_slice

          y[i,0] = lr/IMG_SIZE
          y[i,1] = lc/IMG_SIZE
          y[i,2] = n_h/IMG_SIZE
          y[i,3] = n_w/IMG_SIZE
          y[i,4+p_id] = 1
        y[i,7] = appear

      yield X/255.0, y

xx = None
yy = None
for x, y in data_generator():
  xx, yy = x, y
  break

plt.imshow(xx[5])

def custom_loss(y_true, y_pred):
  bce = binary_crossentropy(y_true[:,:4], y_pred[:,:4])
  bce2 = binary_crossentropy(y_true[:,-1], y_pred[:,-1])
  cce = categorical_crossentropy(y_true[:,4:7], y_pred[:,4:7])
  return bce*y_true[:,-1] + cce*y_true[:,-1] + bce2

def make_model():
  vgg = tf.keras.applications.VGG19(include_top=False, weights='imagenet', input_shape=(IMG_SIZE, IMG_SIZE, 3))
  x = Flatten()(vgg.output)
  x1 = Dense(4, activation=tf.keras.activations.sigmoid)(x)
  x2 = Dense(3, activation=tf.keras.activations.softmax)(x)
  x3 = Dense(1, activation=tf.keras.activations.sigmoid)(x)
  x = Concatenate()([x1, x2, x3])
  model = Model(vgg.input, x)
  model.compile(optimizer=Adam(learning_rate=0.0001), loss=custom_loss)
  return model

model = make_model()
model.fit(x=data_generator(), epochs=10, steps_per_epoch=50)

from matplotlib.patches import Rectangle

def make_prediction():
  x = np.zeros((IMG_SIZE, IMG_SIZE, 3))
  random_bg = np.random.choice(len(backgrounds))
  bg = backgrounds[random_bg]
  bg_h, bg_w, _ = bg.shape
  blr = np.random.randint(low=0, high=(bg_h-IMG_SIZE+1))
  blc = np.random.randint(low=0, high=(bg_w-IMG_SIZE+1))
  x = bg[blr:blr+IMG_SIZE,blc:blc+IMG_SIZE].copy()

  appear = (np.random.random() < 0.75)

  if appear:
    p_id = np.random.choice(len(pokemon))
    pk, h, w, _ = pokemon[p_id]
    scale = 0.5 + np.random.random()
    n_h = int(h*scale)
    n_w = int(w*scale)
    obj = resize(pk, (n_h, n_w), preserve_range=True).astype(np.uint8)

    if np.random.random() > 0.5:
      obj = np.fliplr(obj)

    lr = np.random.randint(low=0, high=(IMG_SIZE-n_h+1))
    lc = np.random.randint(low=0, high=(IMG_SIZE-n_w+1))
    rr = lr + n_h - 1
    rc = lc + n_w - 1

    mask = (obj[:,:,3] == 0)
    bg_slice = x[lr:rr+1,lc:rc+1,:]
    bg_slice = np.expand_dims(mask, -1) * bg_slice
    bg_slice += obj[:,:,:3]
    x[lr:rr+1,lc:rc+1,:] = bg_slice
    actual_class = classes[p_id]

  X = np.expand_dims(x, axis=0)/255.0
  p = model.predict(X)[0]

  fig, ax = plt.subplots(1)
  ax.imshow(x.astype(np.uint8))

  if p[-1] > 0.5:
    row0 = int(p[0]*IMG_SIZE)
    col0 = int(p[1]*IMG_SIZE)
    row1 = int(row0 + p[2]*IMG_SIZE)
    col1 = int(col0 + p[3]*IMG_SIZE)
    class_pred_idx = np.argmax(p[4:7])
    class_pred = classes[class_pred_idx]
    print("pred:", row0, col0, row1, col1, class_pred)
    rect = Rectangle(
        (p[1]*IMG_SIZE, p[0]*IMG_SIZE),
        p[3]*IMG_SIZE, p[2]*IMG_SIZE,linewidth=1,edgecolor='r',facecolor='none')
    ax.add_patch(rect)
  else:
    print("pred: no object")
  plt.show()

make_prediction()